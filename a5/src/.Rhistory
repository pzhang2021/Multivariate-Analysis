kellog <- read.csv("~/Library/Mobile Documents/com~apple~CloudDocs/Graduate Study/Advanced Data Analysis/Assignment/a5/src/kellog.dat", sep="")
View(kellog)
library(haven)
dataset <- read_stata(NULL)
View(dataset)
library(MASS)
library(MASS)
library(MASS)
# Economic and fertility measures of swiss towns
# in the late 19th century
data(swiss)
head(swiss)
# Remove the fertility parameter of interest
swiss.x = as.matrix(swiss[, -1])
head(swiss.x)
# Compute the distance function (since all are numeric)
swiss.dist = dist(swiss.x)
swiss.dist
swiss.mds = isoMDS(swiss.dist)  # cmdscale doesn't have a nice Shepard diagram
swiss.mds$stress   # Note ... this is in %, so is very low = .023
# Now plot the MDS
plot(swiss.mds$points, type = "n")
text(swiss.mds$points, labels = as.character(1:nrow(swiss.x)))
# Plotting a Shepard diagram happens in three steps
# First we set up the plot with Shepard
swiss.sh = Shepard(swiss.dist, swiss.mds$points)
# Then we plot the points
plot(swiss.sh, pch = ".")
# Economic and fertility measures of swiss towns
# in the late 19th century
data(swiss)
head(swiss)
# Remove the fertility parameter of interest
swiss.x = as.matrix(swiss[, -1])
head(swiss.x)
# Compute the distance function (since all are numeric)
swiss.dist = dist(swiss.x)
swiss.dist
swiss.mds = isoMDS(swiss.dist)  # cmdscale doesn't have a nice Shepard diagram
swiss.mds$stress   # Note ... this is in %, so is very low = .023
# Now plot the MDS
plot(swiss.mds$points, type = "n")
text(swiss.mds$points, labels = as.character(1:nrow(swiss.x)))
# Plotting a Shepard diagram happens in three steps
# First we set up the plot with Shepard
swiss.sh = Shepard(swiss.dist, swiss.mds$points)
# Then we plot the points
plot(swiss.sh, pch = ".")
# Then we plot the lines
lines(swiss.sh$x, swiss.sh$yf, type = "S", col="red")
# Nicely clustered along the step line
# Nicely clustered along the step line
# Nicely clustered along the step line
data = read.csv("data_marsh_cleaned.csv")
View(data)
# p1
water = ds[, 2:6]
# p1
water = ds[, 2:6]
# p1
water = data[, 2:6]
soil = data[, 7:9]
View(soil)
library(CCA)
install.packages("CCA")
library(CCA)
ccSoil = cc(water, soil)
ccSoil$cor
ccWater = cc(soil, water)
ccWater$cor
wilksSoil = ccaWilks(water, soil, ccSoil)
ccaWilks = function(set1, set2, cca)
{
ev = ((1 - cca$cor^2))
ev
n = dim(set1)[1]
p = length(set1)
q = length(set2)
k = min(p, q)
m = n - 3/2 - (p + q)/2
m
w = rev(cumprod(rev(ev)))
# initialize
d1 = d2 = f = vector("numeric", k)
for (i in 1:k)
{
s = sqrt((p^2 * q^2 - 4)/(p^2 + q^2 - 5))
si = 1/s
d1[i] = p * q
d2[i] = m * s - p * q/2 + 1
r = (1 - w[i]^si)/w[i]^si
f[i] = r * d2[i]/d1[i]
p = p - 1
q = q - 1
}
pv = pf(f, d1, d2, lower.tail = FALSE)
dmat = cbind(WilksL = w, F = f, df1 = d1, df2 = d2, p = pv)
}
wilksSoil = ccaWilks(water, soil, ccSoil)
round(wilksSoil, 2)
round(wilksSoil, 3)
round(wilksSoil, 2)
names(ccSoil)
round(-ccSoil$xcoef, 3)
round(-ccSoil$ycoef, 3)
ccSoil = cc(water, soil)
ccSoil
# p2
loadingsSoil = comput(water, soil, ccSoil)
ls(loadingsSoil)
round(-loadingsSoil$corr.X.xscores, 2)
round(-loadingsSoil$corr.Y.yscores, 2)
